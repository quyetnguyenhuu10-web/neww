/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

"use strict";var e=require("lexical");function t(e,...t){const n=new URL("https://lexical.dev/docs/error"),o=new URLSearchParams;o.append("code",e);for(const e of t)o.append("v",e);throw n.search=o.toString(),Error(`Minified Lexical error #${e}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}const n=new Map;function o(e){let t=e;for(;null!=t;){if(t.nodeType===Node.TEXT_NODE)return t;t=t.firstChild}return null}function s(e){const t=e.parentNode;if(null==t)throw new Error("Should never happen");return[t,Array.from(t.childNodes).indexOf(e)]}function r(e){const t={};if(!e)return t;const n=e.split(";");for(const e of n)if(""!==e){const[n,o]=e.split(/:([^]+)/);n&&o&&(t[n.trim()]=o.trim())}return t}function i(e){let t=n.get(e);return void 0===t&&(t=r(e),n.set(e,t)),t}function l(e){let t="";for(const n in e)n&&(t+=`${n}: ${e[n]};`);return t}function c(t){const n=e.$getEditor().getElementByKey(t.getKey());if(null===n)return null;const o=n.ownerDocument.defaultView;return null===o?null:o.getComputedStyle(n)}function f(t){return c(e.$isRootNode(t)?t:t.getParentOrThrow())}function d(t,n,o){let s=n.getNode(),r=o;if(e.$isElementNode(s)){const e=s.getDescendantByIndex(n.offset);null!==e&&(s=e)}for(;r>0&&null!==s;){if(e.$isElementNode(s)){const e=s.getLastDescendant();null!==e&&(s=e)}let o=s.getPreviousSibling(),i=0;if(null===o){let e=s.getParentOrThrow(),t=e.getPreviousSibling();for(;null===t;){if(e=e.getParent(),null===e){o=null;break}t=e.getPreviousSibling()}null!==e&&(i=e.isInline()?0:2,o=t)}let l=s.getTextContent();""===l&&e.$isElementNode(s)&&!s.isInline()&&(l="\n\n");const c=l.length;if(!e.$isTextNode(s)||r>=c){const t=s.getParent();s.remove(),null==t||0!==t.getChildrenSize()||e.$isRootNode(t)||t.remove(),r-=c+i,s=o}else{const o=s.getKey(),i=t.getEditorState().read(()=>{const t=e.$getNodeByKey(o);return e.$isTextNode(t)&&t.isSimpleText()?t.getTextContent():null}),f=c-r,d=l.slice(0,f);if(null!==i&&i!==l){const t=e.$getPreviousSelection();let n=s;if(s.isSimpleText())s.setTextContent(i);else{const t=e.$createTextNode(i);s.replace(t),n=t}if(e.$isRangeSelection(t)&&t.isCollapsed()){const e=t.anchor.offset;n.select(e,e)}}else if(s.isSimpleText()){const e=n.key===o;let t=n.offset;t<r&&(t=c);const i=e?t-r:0,l=e?t:f;if(e&&0===i){const[e]=s.splitText(i,l);e.remove()}else{const[,e]=s.splitText(i,l);e.remove()}}else{const t=e.$createTextNode(d);s.replace(t)}r=0}}}function a(o,s){(e.$isRangeSelection(o)?o.isCollapsed():e.$isTextNode(o)||e.$isElementNode(o))||t(280);const r=i(e.$isRangeSelection(o)?o.style:e.$isTextNode(o)?o.getStyle():o.getTextStyle()),c=Object.entries(s).reduce((e,[t,n])=>("function"==typeof n?e[t]=n(r[t],o):null===n?delete e[t]:e[t]=n,e),{...r}),f=l(c);e.$isRangeSelection(o)||e.$isTextNode(o)?o.setStyle(f):o.setTextStyle(f),n.set(f,c)}function u(t){const n=e.$getSelection();if(!n)return;const o=new Map,s=e=>o.get(e.getKey())||[0,e.getTextContentSize()];if(e.$isRangeSelection(n))for(const t of e.$caretRangeFromSelection(n).getTextSlices())t&&o.set(t.caret.origin.getKey(),t.getSliceIndices());const r=n.getNodes();for(const n of r){if(!e.$isTextNode(n)||!n.canHaveFormat())continue;const[o,r]=s(n);if(r!==o)if(e.$isTokenOrSegmented(n)||0===o&&r===n.getTextContentSize())t(n);else{t(n.splitText(o,r)[0===o?0:1])}}e.$isRangeSelection(n)&&"text"===n.anchor.type&&"text"===n.focus.type&&n.anchor.key===n.focus.key&&g(n)}function g(e){if(e.isBackward()){const{anchor:t,focus:n}=e,{key:o,offset:s,type:r}=t;t.set(n.key,n.offset,n.type),n.set(o,s,r)}}function p(e,t){const n=e.getFormatType(),o=e.getIndent();n!==t.getFormatType()&&t.setFormat(n),o!==t.getIndent()&&t.setIndent(o)}function $(e){return e.getNode().isAttached()}function h(t){let n=t;for(;null!==n&&!e.$isRootOrShadowRoot(n);){const e=n.getLatest(),t=n.getParent();0===e.getChildrenSize()&&n.remove(!0),n=t}}function y(n,o,s,r,i=null){if(0===o.length)return;const l=o[0],c=new Map,f=[];let d=e.$isElementNode(l)?l:l.getParentOrThrow();d.isInline()&&(d=d.getParentOrThrow());let a=!1;for(;null!==d;){const t=d.getPreviousSibling();if(null!==t){d=t,a=!0;break}if(d=d.getParentOrThrow(),e.$isRootOrShadowRoot(d))break}const u=new Set;for(let t=0;t<s;t++){const n=o[t];e.$isElementNode(n)&&0===n.getChildrenSize()&&u.add(n.getKey())}const g=new Set;for(let n=0;n<s;n++){const s=o[n];let i=s.getParent();if(null!==i&&i.isInline()&&(i=i.getParent()),null!==i&&e.$isLeafNode(s)&&!g.has(s.getKey())){const t=i.getKey();if(void 0===c.get(t)){const n=r();n.setFormat(i.getFormatType()),n.setIndent(i.getIndent()),f.push(n),c.set(t,n),i.getChildren().forEach(t=>{n.append(t),g.add(t.getKey()),e.$isElementNode(t)&&t.getChildrenKeys().forEach(e=>g.add(e))}),h(i)}}else if(u.has(s.getKey())){e.$isElementNode(s)||t(179);const n=r();n.setFormat(s.getFormatType()),n.setIndent(s.getIndent()),f.push(n),s.remove(!0)}}if(null!==i)for(let e=0;e<f.length;e++){const t=f[e];i.append(t)}let p=null;if(e.$isRootOrShadowRoot(d))if(a)if(null!==i)d.insertAfter(i);else for(let e=f.length-1;e>=0;e--){const t=f[e];d.insertAfter(t)}else{const t=d.getFirstChild();if(e.$isElementNode(t)&&(d=t),null===t)if(i)d.append(i);else for(let e=0;e<f.length;e++){const t=f[e];d.append(t),p=t}else if(null!==i)t.insertBefore(i);else for(let e=0;e<f.length;e++){const n=f[e];t.insertBefore(n),p=n}}else if(i)d.insertAfter(i);else for(let e=f.length-1;e>=0;e--){const t=f[e];d.insertAfter(t),p=t}const y=e.$getPreviousSelection();e.$isRangeSelection(y)&&$(y.anchor)&&$(y.focus)?e.$setSelection(y.clone()):null!==p?p.selectEnd():n.dirty=!0}function m(e){const t=S(e);return null!==t&&"vertical-rl"===t.writingMode}function S(t){const n=t.anchor.getNode();return e.$isElementNode(n)?c(n):f(n)}function N(e,t,n,o){e.modify(t?"extend":"move",n,o)}function x(e){const t=S(e);return null!==t&&"rtl"===t.direction}function T(e,t,n){const o=i(e.getStyle());return null!==o&&o[t]||n}const E=d;exports.$cloneWithProperties=e.$cloneWithProperties,exports.$selectAll=e.$selectAll,exports.$addNodeStyle=function(e){const t=e.getStyle(),o=r(t);n.set(t,o)},exports.$copyBlockFormatIndent=p,exports.$ensureForwardRangeSelection=g,exports.$forEachSelectedTextNode=u,exports.$getComputedStyleForElement=c,exports.$getComputedStyleForParent=f,exports.$getSelectionStyleValueForProperty=function(t,n,o=""){let s=null;const r=t.getNodes(),l=t.anchor,c=t.focus,f=t.isBackward(),d=f?c.offset:l.offset,a=f?c.getNode():l.getNode();if(e.$isRangeSelection(t)&&t.isCollapsed()&&""!==t.style){const e=i(t.style);if(null!==e&&n in e)return e[n]}for(let t=0;t<r.length;t++){const i=r[t];if((0===t||0!==d||!i.is(a))&&e.$isTextNode(i)){const e=T(i,n,o);if(null===s)s=e;else if(s!==e){s="";break}}}return null===s?o:s},exports.$isAtNodeEnd=function(n){if("text"===n.type)return n.offset===n.getNode().getTextContentSize();const o=n.getNode();return e.$isElementNode(o)||t(177),n.offset===o.getChildrenSize()},exports.$isParentElementRTL=x,exports.$isParentRTL=function(e){const t=f(e);return null!==t&&"rtl"===t.direction},exports.$moveCaretSelection=N,exports.$moveCharacter=function(e,t,n){const o=x(e);let s;s=m(e)||o?!n:n,N(e,t,s,"character")},exports.$patchStyleText=function(t,n){if(e.$isRangeSelection(t)&&t.isCollapsed()){a(t,n);const o=t.anchor.getNode();e.$isElementNode(o)&&o.isEmpty()&&a(o,n)}u(e=>{a(e,n)});const o=t.getNodes();if(o.length>0){const t=new Set;for(const s of o){if(!e.$isElementNode(s)||!s.canBeEmpty()||0!==s.getChildrenSize())continue;const o=s.getKey();t.has(o)||(t.add(o),a(s,n))}}},exports.$setBlocksType=function(t,n,o=p){if(null===t)return;const s=t.getStartEndPoints(),r=new Map;let i=null;if(s){const[t,n]=s;i=e.$createRangeSelection(),i.anchor.set(t.key,t.offset,t.type),i.focus.set(n.key,n.offset,n.type);const o=e.$findMatchingParent(t.getNode(),e.INTERNAL_$isBlock),l=e.$findMatchingParent(n.getNode(),e.INTERNAL_$isBlock);e.$isElementNode(o)&&r.set(o.getKey(),o),e.$isElementNode(l)&&r.set(l.getKey(),l)}for(const n of t.getNodes())if(e.$isElementNode(n)&&e.INTERNAL_$isBlock(n))r.set(n.getKey(),n);else if(null===s){const t=e.$findMatchingParent(n,e.INTERNAL_$isBlock);e.$isElementNode(t)&&r.set(t.getKey(),t)}for(const[e,t]of r){const s=n();o(t,s),t.replace(s,!0),i&&(e===i.anchor.key&&i.anchor.set(s.getKey(),i.anchor.offset,i.anchor.type),e===i.focus.key&&i.focus.set(s.getKey(),i.focus.offset,i.focus.type))}i&&t.is(e.$getSelection())&&e.$setSelection(i)},exports.$shouldOverrideDefaultCharacterSelection=function(t,n){let o=m(t)?!n:n;x(t)&&(o=!o);const s=e.$caretFromPoint(t.focus,o?"previous":"next");if(e.$isExtendableTextPointCaret(s))return!1;for(const t of e.$extendCaretToRange(s)){if(e.$isChildCaret(t))return!t.origin.isInline();if(!e.$isElementNode(t.origin)){if(e.$isDecoratorNode(t.origin))return!0;break}}return!1},exports.$sliceSelectedTextNodeContent=function(t,n,o="self"){const s=t.getStartEndPoints();if(n.isSelected(t)&&!e.$isTokenOrSegmented(n)&&null!==s){const[r,i]=s,l=t.isBackward(),c=r.getNode(),f=i.getNode(),d=n.is(c),a=n.is(f);if(d||a){const[s,r]=e.$getCharacterOffsets(t),i=c.is(f),d=n.is(l?f:c),a=n.is(l?c:f);let u,g=0;if(i)g=s>r?r:s,u=s>r?s:r;else if(d){g=l?r:s,u=void 0}else if(a){g=0,u=l?s:r}const p=n.__text.slice(g,u);p!==n.__text&&("clone"===o&&(n=e.$cloneWithPropertiesEphemeral(n)),n.__text=p)}}return n},exports.$trimTextContentFromAnchor=d,exports.$wrapNodes=function(t,n,o=null){const s=t.getStartEndPoints(),r=s?s[0]:null,i=t.getNodes(),l=i.length;if(null!==r&&(0===l||1===l&&"element"===r.type&&0===r.getNode().getChildrenSize())){const e="text"===r.type?r.getNode().getParentOrThrow():r.getNode(),t=e.getChildren();let s=n();return s.setFormat(e.getFormatType()),s.setIndent(e.getIndent()),t.forEach(e=>s.append(e)),o&&(s=o.append(s)),void e.replace(s)}let c=null,f=[];for(let s=0;s<l;s++){const r=i[s];e.$isRootOrShadowRoot(r)?(y(t,f,f.length,n,o),f=[],c=r):null===c||null!==c&&e.$hasAncestor(r,c)?f.push(r):(y(t,f,f.length,n,o),f=[r])}y(t,f,f.length,n,o)},exports.createDOMRange=function(t,n,r,i,l){const c=n.getKey(),f=i.getKey(),d=document.createRange();let a=t.getElementByKey(c),u=t.getElementByKey(f),g=r,p=l;if(e.$isTextNode(n)&&(a=o(a)),e.$isTextNode(i)&&(u=o(u)),void 0===n||void 0===i||null===a||null===u)return null;"BR"===a.nodeName&&([a,g]=s(a)),"BR"===u.nodeName&&([u,p]=s(u));const $=a.firstChild;a===u&&null!=$&&"BR"===$.nodeName&&0===g&&0===p&&(p=1);try{d.setStart(a,g),d.setEnd(u,p)}catch(e){return null}return!d.collapsed||g===p&&c===f||(d.setStart(u,p),d.setEnd(a,g)),d},exports.createRectsFromDOMRange=function(e,t){const n=e.getRootElement();if(null===n)return[];const o=n.getBoundingClientRect(),s=getComputedStyle(n),r=parseFloat(s.paddingLeft)+parseFloat(s.paddingRight),i=Array.from(t.getClientRects());let l,c=i.length;i.sort((e,t)=>{const n=e.top-t.top;return Math.abs(n)<=3?e.left-t.left:n});for(let e=0;e<c;e++){const t=i[e],n=l&&l.top<=t.top&&l.top+l.height>t.top&&l.left+l.width>t.left,s=t.width+r===o.width;n||s?(i.splice(e--,1),c--):l=t}return i},exports.getCSSFromStyleObject=l,exports.getStyleObjectFromCSS=i,exports.trimTextContentFromAnchor=E;
